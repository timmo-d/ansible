---
# Create or update proxied CNAME DNS records for each Access app
# Uses the first entry in self_hosted_domains[] as the public hostname.

- name: Get Zone ID for base domain
  uri:
    url: "https://api.cloudflare.com/client/v4/zones?name={{ cloudflare_zone }}"
    method: GET
    headers:
      Authorization: "Bearer {{ cloudflare_api_token }}"
      Content-Type: "application/json"
    return_content: yes
    status_code: 200
  register: zone_lookup

- name: Fail if zone lookup failed
  fail:
    msg: "Failed to retrieve zone ID for {{ cloudflare_zone }}: {{ zone_lookup.json.errors }}"
  when: not zone_lookup.json.success | default(false)

- name: Set zone_id fact
  set_fact:
    cloudflare_zone_id: "{{ zone_lookup.json.result[0].id }}"

# Read the credentials JSON to get the TunnelID
#- name: Read tunnel credentials file
#  slurp:
#    src: "/etc/cloudflared/*.json"
#  register: tunnel_creds_raw

#- name: Set tunnel_id_final fact from credentials file
#  set_fact:
#    tunnel_id_final: "{{ (tunnel_creds_raw.content | b64decode | from_json).TunnelID }}"

# Step 1: Initialise empty list for filtered apps
- name: Initialise apps_with_domains
  set_fact:
    apps_with_domains: []

# Step 2: Append only apps that have self_hosted_domains
- name: Collect apps with self_hosted_domains
  set_fact:
    apps_with_domains: "{{ apps_with_domains + [ item ] }}"
  loop: "{{ access_apps_list | default([]) }}"
  when:
    - item is mapping
    - item.self_hosted_domains is defined
    - item.self_hosted_domains | length > 0

# Step 3: Debug to confirm filtered apps
- name: Show filtered apps
  debug:
    var: apps_with_domains

# Step 4: Build list of public hostnames
- name: Build list of public hostnames
  set_fact:
    app_hostnames: "{{ app_hostnames | default([]) + [ {'public_hostname': item.self_hosted_domains[0]} ] }}"
  loop: "{{ apps_with_domains }}"
  loop_control:
    loop_var: item

# Step 5: Debug to confirm hostnames
- name: Show hostnames to be created
  debug:
    var: app_hostnames

# Ensure proxied CNAME DNS records exist for each Access app
# Uses the community.general.cloudflare_dns module for idempotency

- name: Ensure CNAME record exists for each Access app
  community.general.cloudflare_dns:
    zone: "{{ cloudflare_zone }}"
    record: "{{ item.public_hostname }}"
    type: CNAME
    value: "{{ tunnel_id_final }}.cfargotunnel.com"
    proxied: true
    ttl: 1
    api_token: "{{ cloudflare_api_token }}"
    state: present
  loop: "{{ app_hostnames }}"
  loop_control:
    label: "{{ item.public_hostname }}"


# Step 6: Create or update DNS records
#- name: Ensure proxied CNAME record exists for each Access app
#  uri:
#    url: "https://api.cloudflare.com/client/v4/zones/{{ cloudflare_zone_id }}/dns_records"
#    method: POST
#    headers:
#      Authorization: "Bearer {{ cloudflare_api_token }}"
#      Content-Type: "application/json"
#    body_format: json
#    body:
#      type: "CNAME"
#      name: "{{ item.public_hostname }}"
#      content: "{{ tunnel_id_final }}.cfargotunnel.com"
#      proxied: true
#      ttl: 1
#    status_code: 200
#    return_content: yes
#  loop: "{{ app_hostnames }}"
#  loop_control:
#    label: "{{ item.public_hostname }}"
#  register: dns_create_results

# Step 7: Show DNS creation results
- name: Show DNS creation results
  debug:
    var: dns_create_results.results
